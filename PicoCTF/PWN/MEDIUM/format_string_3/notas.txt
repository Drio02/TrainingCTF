En este reto me dan varias cosas. Me dan la libreria libc, el binario, el codig fuente y el linker para la biblioteca
Al analizar el codigo fuente llama la atencion lo siguiente:

char *normal_string = "/bin/sh";

El string para llamar un bash o por lo menos la direccion de bash. Y al final se hace un puts() de ese string. Lo
tenemos que hacer es sobreescribir el GOT para que en vez de que llame a puts() llame a system() para que 
me levante una bash interactiva. Se tiene que sobreescribir el GOT ya que es el que tiene las entradas de
las funciones standard de la biblioteca de C. 

Se analiza eso por 2 pistas.

1- Por el string "/bin/sh"
2- Porque nos estan dando la biblioteca y el linker

Le ejecuto un checksec al binario:

    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        No PIE (0x3ff000)
    RUNPATH:    b'.'
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No

Notamos que el PIE esta desactivado y el RELRO esta parcialmente activo. Que quiere decir con lo del RELRO.

# RELRO (Realocation Read-Only)
Opcion de seguridad que hace ciertas partes del ELF (Executable and Linkable Format) solo de read-only para prevenir
sobreescritura.

Tiene 2 modos:
1. Partial RELRO: Que esto lo que quiere decir es que mueve el GOT a una ubicacion donde no puede ser sobreescrita
direcctamente con un buffer overflow.
2. Full RELRO: Convierte a todo el GOT en campos de read-only, lo que le da mas proteccion contra ataques de sobreescritura
de GOT.

Vamos a aprovecharnos de que esta parcialmente activo. Al ejecutar el programa varias veces, notamos que la
direccion de la funcion setvbuf() cambia contstantemente, entonces decidimos revisar con checksec la bibliteca.

    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    SHSTK:      Enabled
    IBT:        Enabled

Como podemos ver tiene el PIE (Position Independent Executable) activado, entonces las direcciones van a cambiar.

Como todo payload de format string, buscamos primero el offset, que es el slot de memoria que escribimos de primero:

Howdy gamers!
Okay I'll be nice. Here's the address of setvbuf in libc: 0x7ffff7e5a3f0
AAAAAAAA%38$p
AAAAAAAA0x4141414141414141
/bin/sh

Como lo notamos, es el slot 38, entonces el offset es 38.

Ahora tenemos que encontrar la direccion de entrada en el GOT para la funcion puts(), hacemos un disassemble
a main:

call   0x401080 <puts@plt>

Okey tenemos que la direccion 0x401080 en la PLT es para puts(), ahora le hacemos un disassemble a esta direccion:

disas 0x401080
Dump of assembler code for function puts@plt:
   0x0000000000401080 <+0>:	endbr64
   0x0000000000401084 <+4>:	bnd jmp *0x2f8d(%rip)        # 0x404018 <puts@got.plt>
   0x000000000040108b <+11>:	nopl   0x0(%rax,%rax,1)

Y vemos que la direccion de entrada para puts() en GOT es la, 0x404018.Ya tenemos la direccion de entrada. Ya que
el binarion format-string-3 no tiene activo el PIE esta direccion no va a cambiar.

Tenemos que calcular la direccion de system(), como el PIE esta activo a direccion va a cambiar, pero el offset entre
setvbuf() y system() siempre va a ser el mismo. Entonces obtenemos con gdb la direccion de ambas y calculamos la 
diferencia:

(gdb) x/gx &setvbuf
0x7ffff7e5a3f0 <setvbuf>:	0x55415641fa1e0ff3
(gdb) x/gx &system
0x7ffff7e2f760 <system>:	0x74ff8548fa1e0ff3

Diferencia -> 175248

Ahora lo que queda es escribir el exploit, va a estar en esta misma carpeta con el nombre de exploit.py. Se va 
realizar con pwntools y su instruccion fmtstr_payload.

Ponemos todas las configuraciones necesarias y ejecutamos el exploit. Cuando vemos que funciona a nivel local. Lo hacemos
con el server.
$ls
Makefile
artifacts.tar.gz
flag.txt
format-string-3
format-string-3.c
ld-linux-x86-64.so.2
libc.so.6
metadata.json
profile
$ cat flag.txt
picoCTF{G07_G07?_cf6cb591}[*] Got EOF while reading in interactive

Con eso obtuvimos la flag.

NOTA: Estudiar lo siguiente:

- Como funciona el GOT y la PLT
- Porque no va a cambiar la direccion del GOT ya que el PIE no esta activo en el binario
